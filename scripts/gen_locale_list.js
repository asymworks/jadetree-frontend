const { ArgumentParser } = require('argparse');
const { version } = require('../package.json');

var fs = require('fs');

var { template } = require('lodash');

const dateFnsLocales = require('date-fns/locale');
const jadetreeLocales = require('@jadetree/currency/locales');
const { parseLocale, negotiateLocale } = require('@jadetree/currency');

const territoryInfo = require('cldr-core/supplemental/territoryInfo.json');

// L10N Locale List Data Template
const ts_lists_template = `/* eslint-disable no-multi-spaces, no-trailing-spaces */
/**
 * Automatically generated by gen_locale_list.py
 * @packageDocumentation
 * @internal
 */

/** Locale Tags supported by \`date-fns\` */
export const DateFnsAvailable = <%= dateFnsTags %>

/** Locale Tags supported by \`@jadetree/currency\` */
export const JadeTreeAvailable = <%= jadetreeTags %>

/** Set of Locale Tags supported by either library */
export const Available = <%= bothTags %>

/** Territory to Language Mapping */
export const TerritoryLanguages: { [key: string]: string } = {
<% territoryLangs.forEach((itm) => { %>  <%= itm.code %>: '<%= itm.lang %>',
<% }); %>};
`;

/**
 * Format a long array into aligned columns
 */
function formatArray(items, maxLen=80, indent=2) {
  const maxItemLen = items.reduce(
    (acc, cur) => cur.length > acc ? cur.length : acc,
    0
  );

  const nPerLine = Math.floor((maxLen - indent) / (maxItemLen + 4));
  const nLines = Math.ceil(items.length / nPerLine);
  const lines = [];

  for (let i = 0; i < nLines; i += 1) {
    const line = items
      .slice(i * nPerLine, (i + 1) * nPerLine)
      .map((i) => `'${i}', ${' '.repeat(maxItemLen - i.length)}`)
      .join('');
    lines.push(`${' '.repeat(indent)}${line}`);
  }

  return `[\n${lines.join('\n')}\n];`;
}

function main(args) {
  // Generate Lists of normalized (underscore-separated) locale tags
  const dateFnsTags = Object.values(dateFnsLocales)
    .map((l) => l.code.replace(/-/, '_'));
  const jadetreeTags = Object.keys(jadetreeLocales);

  // Generate intersection
  const bothTags = jadetreeTags
    .filter((tag) => negotiateLocale([tag], dateFnsTags))
    .filter((tag) => !parseLocale(tag).variant)
  const options = { dateFnsTags, jadetreeTags, bothTags };

  // Generate Territory-Language Mapping
  const ti = territoryInfo.supplemental.territoryInfo;
  const territoryLangs = Object.keys(ti)
    .filter((t) => ti[t].languagePopulation)
    .map((t) => ({
      code: t,
      lang: Object.keys(ti[t].languagePopulation)
        .find((l) => ti[t].languagePopulation[l]._officialStatus === 'official')
    }))
    .filter((itm) => itm.lang);

  // Write output
  if (!args.output || args.output === '-') {
    const options = { dateFnsTags, jadetreeTags, bothTags };
    process.stdout.write(`${JSON.stringify(options)}\n`);
  } else {
    const options = {
      dateFnsTags: formatArray(dateFnsTags),
      jadetreeTags: formatArray(jadetreeTags),
      bothTags: formatArray(bothTags),
      territoryLangs,
    };
    fs.writeFileSync(
      args.output,
      template(ts_lists_template)(options)
    );
  }
}

const parser = new ArgumentParser({
  description: 'Generates the list of supported locales for the Jade Tree '
    + 'Frontend application',
});

parser.add_argument('-v', '--version', { action: 'version', version });
parser.add_argument('-o', '--output', { help: 'currency list output file (default writes to STDOUT)', default: '-' });

const args = parser.parse_args();

main(args);
